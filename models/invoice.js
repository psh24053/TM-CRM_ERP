/**
Copyright 2017 ToManage

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

@author    ToManage SAS <contact@tomanage.fr>
@copyright 2014-2017 ToManage SAS
@license   http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0
International Registered Trademark & Property of ToManage SAS
*/



"use strict";

/**
 * Module dependencies.
 */
var mongoose = require('mongoose'),
		moment = require('moment'),
		async = require('async'),
		fs = require('fs'),
		Schema = mongoose.Schema,
		ObjectId = mongoose.Schema.Types.ObjectId,
		timestamps = require('mongoose-timestamp');

var DataTable = require('mongoose-datatable');
DataTable.configure({
		verbose: false,
		debug: false
});
mongoose.plugin(DataTable.init);

var Dict = INCLUDE('dict');
var Latex = INCLUDE('latex');

var setPrice = MODULE('utils').setPrice;
var setDate = MODULE('utils').setDate;
const round = MODULE('utils').round;

const pdfSchema = new Schema({
		// _id needed for download pdf file
		filename: {
				type: String
		}, //File to display in list
		fileId: {
				type: String
		}, //FileId in directory
		modelPdf: {
				type: ObjectId,
				ref: 'modelspdf'
		},
		datec: {
				type: Date,
				default: Date.now
		}, // creation date
		dateu: Date //date last download file
}, {
		toObject: {
				virtuals: true
		},
		toJSON: {
				virtuals: true
		}
});

pdfSchema.virtual('token')
		.get(function() {
				var CryptoJS = require("crypto-js");

				if (!CONFIG('sha1-secret'))
						return "";

				return CryptoJS.SHA1(CONFIG('sha1-secret') + this.fileId.toUpperCase()).toString();
		});

/**
 * Invoice Schema
 */
var billSchema = new Schema({
		// true client false fournisseur
		forSales: {
				type: Boolean,
				default: true
		},
		ref: {
				type: String,
				index: true
		},
		isremoved: Boolean,
		ID: {
				type: Number
		},
		/*title: {//For internal use only
		 ref: String,
		 autoGenerated: {type: Boolean, default: false} //For automatic process generated bills
		 },*/

		pdfModel: {
				modelId: {
						type: Schema.Types.ObjectId,
						ref: 'modelspdf'
				},
				htop: {
						type: Number,
						default: 0
				}, //Space in cm before the lines array
				hbuttom: {
						type: Number,
						default: 0
				}, //Space in cm after the lines array
		},

		currency: {
				_id: {
						type: String,
						ref: 'currency',
						default: ''
				},
				rate: {
						type: Number,
						default: 1
				} // changed default to '0' for catching errors
		},
		Status: {
				type: String,
				default: 'DRAFT'
		},
		cond_reglement_code: {
				type: String,
				default: 'RECEP'
		},
		mode_reglement_code: {
				type: String,
				default: 'TIP'
		},
		bank_reglement: {
				type: ObjectId,
				ref: 'bank'
		},
		//availability_code: {type: String, default: 'AV_NOW'},
		type: {
				type: String,
				default: 'SRC_COMM'
		},
		supplier: {
				type: Schema.Types.ObjectId,
				ref: 'Customers',
				require: true
		},
		contacts: [{
				type: Schema.Types.ObjectId,
				ref: 'Customers'
		}],
		ref_client: {
				type: String,
				default: ""
		},

		imported: {
				type: Boolean,
				default: false
		}, //imported in accounting
		journalId: [Schema.Types.ObjectId], // Id transactions for accounting

		orders: [{
				type: Schema.Types.ObjectId,
				ref: 'order'
		}],

		datec: {
				type: Date,
				default: new Date,
				set: setDate
		},
		dater: {
				type: Date,
				set: setDate
		}, // date limit reglement
		dateOf: {
				type: Date
		}, // Periode de facturation du
		dateTo: {
				type: Date
		}, // au
		notes: [{
				title: String,
				note: String,
				public: {
						type: Boolean,
						default: false
				},
				edit: {
						type: Boolean,
						default: false
				}
		}],
		discount: {
				escompte: {
						percent: {
								type: Number,
								default: 0
						},
						value: {
								type: Number,
								default: 0,
								set: setPrice
						} // total remise globale
				},
				discount: {
						percent: {
								type: Number,
								default: 0
						}, //discount
						value: {
								type: Number,
								default: 0,
								set: setPrice
						} // total remise globale
				}
		},
		total_ht: {
				type: Number,
				default: 0,
				set: setPrice
		},
		correction: {
				type: Number,
				default: 0,
				set: setPrice
		},
		total_taxes: [{
				_id: false,
				taxeId: {
						type: Schema.Types.ObjectId,
						ref: 'taxes'
				},
				value: {
						type: Number,
						default: 0
				}
		}],
		total_ttc: {
				type: Number,
				default: 0,
				set: setPrice
		},
		total_paid: {
				type: Number,
				default: 0,
				set: setPrice
		},
		shipping: {
				total_ht: {
						type: Number,
						default: 0,
						set: setPrice
				},
				total_taxes: [{
						_id: false,
						taxeId: {
								type: Schema.Types.ObjectId,
								ref: 'taxes'
						},
						value: {
								type: Number,
								default: 0
						}
				}],
				/*total_ttc: {
				    type: Number,
				    default: 0
				}*/
		},
		createdBy: {
				type: ObjectId,
				ref: 'Users'
		},
		editedBy: {
				type: ObjectId,
				ref: 'Users'
		},
		salesPerson: {
				type: ObjectId,
				ref: 'Employees'
		}, //commercial_id
		salesTeam: {
				type: ObjectId,
				ref: 'Department'
		},
		entity: String,
		optional: Schema.Types.Mixed,
		delivery_mode: {
				type: String,
				default: "Comptoir"
		},
		billing: {
				type: Schema.Types.ObjectId,
				ref: 'Customers'
		},
		//costList: { type: ObjectId, ref: 'priceList', default: null }, //Not used
		//priceList: { type: ObjectId, ref: 'priceList', default: null },

		address: {
				name: {
						type: String,
						default: ''
				},
				street: {
						type: String,
						default: ''
				},
				city: {
						type: String,
						default: ''
				},
				state: {
						type: String,
						default: ''
				},
				zip: {
						type: String,
						default: ''
				},
				country: {
						type: String,
						ref: 'countries',
						default: 'FR'
				},
				contact: {
						name: {
								type: String,
								default: ''
						},
						phone: {
								type: String,
								set: MODULE('utils').setPhone,
								default: ''
						},
						mobile: {
								type: String,
								set: MODULE('utils').setPhone,
								default: ''
						},
						fax: {
								type: String,
								set: MODULE('utils').setPhone,
								default: ''
						},
						email: {
								type: String,
								lowercase: true,
								trim: true,
								index: true
						}
				}
		},
		weight: {
				type: Number,
				default: 0
		}, // Poids total
		lines: [{
				_id: false,
				//pu: {type: Number, default: 0},
				type: {
						type: String,
						default: 'product'
				}, //Used for subtotal
				refProductSupplier: String, //Only for an order Supplier
				qty: {
						type: Number,
						default: 0
				},
				numLine: {
						type: Number
				}, //LineID for PDF
				/*taxes: [{
				    _id: false,
				    taxeId: { type: Schema.Types.ObjectId, ref: 'taxes' },
				    value: { type: Number }
				}],*/
				//price_base_type: String,
				//title: String,
				priceSpecific: {
						type: Boolean,
						default: false
				},
				pu_ht: {
						type: Number,
						default: 0
				},
				description: String,
				private: String, // Private note
				product_type: String,
				product: {
						type: Schema.Types.ObjectId,
						ref: "product"
				},
				total_taxes: [{
						_id: false,
						taxeId: {
								type: Schema.Types.ObjectId,
								ref: 'taxes'
						},
						value: {
								type: Number
						}
				}],
				/*total_ttc: {
				    type: Number,
				    default: 0
				},*/
				discount: {
						type: Number,
						default: 0
				},
				total_ht: {
						type: Number,
						default: 0,
						set: setPrice
				},
				//weight: { type: Number, default: 0 },
				optional: {
						type: Schema.Types.Mixed
				}
		}],
		history: [{
				date: {
						type: Date,
						default: Date.now
				},
				author: {
						type: ObjectId,
						ref: 'Users'
				},
				mode: String, //email, order, alert, new, ...
				Status: String,
				msg: String
		}],

		whoCanRW: {
				type: String,
				enum: ['owner', 'group', 'everyOne'],
				default: 'everyOne'
		},
		groups: {
				owner: {
						type: ObjectId,
						ref: 'Users',
						default: null
				},
				users: [{
						type: ObjectId,
						ref: 'Users',
						default: null
				}],
				group: [{
						type: ObjectId,
						ref: 'Department',
						default: null
				}]
		},

		pdfs: [pdfSchema], //Link To PDF file in uploads/pdf directory

		project: {
				type: ObjectId,
				ref: 'Project',
				default: null
		},

		//feeBilling: { type: Boolean, default: true }, // Frais de facturation
		oldId: String // Only for import migration
}, {
		toObject: {
				virtuals: true
		},
		toJSON: {
				virtuals: true
		}
});

billSchema.plugin(timestamps);

// Gets listing
billSchema.statics.query = function(options, callback) {
		const self = this;

		var data = options.query;
		var quickSearch = data.quickSearch;
		const limit = options.limit;
		const skip = options.skip;

		const FilterMapper = MODULE('helper').filterMapper;
		var filterMapper = new FilterMapper();

		var accessRollSearcher;
		var contentSearcher;
		var waterfallTasks;
		var contentType = data.contentType;
		var sort = {};
		var filter = data.filter && JSON.parse(data.filter) || {};
		var key;

		var filterObject = {
				isremoved: {
						$ne: true
				},
				forSales: (options.query.forSales == 'false' ? false : true)
		};
		var optionsObject = {};
		var matchObject = {};
		var regExp;
		var pastDue = filter.pastDue;

		if (quickSearch) {
				regExp = new RegExp(quickSearch, 'ig');
				matchObject['ref'] = {
						$regex: regExp
				};
				filter = {};
		}

		if (filter && filter.salesPerson && filter.salesPerson.value.length)
				filter.Status.value = [];
		if (filter && filter.supplier && filter.supplier.value.length)
				filter.Status.value = [];


		//TODO refresh Status on angular
		if (filter && filter.Status && filter.Status.value[0])
				switch (filter.Status.value[0]) {
						case 'LIST':
								filter.Status.value = [];
								filterObject.Status = {
										$ne: "PAID"
								};
								break;
						case 'VALIDATE':
								filter.Status.value = [];
								filterObject.Status = 'NOT_PAID';
								filterObject.dater = {
										$gt: moment().subtract(10, 'days').toDate()
								};
								break;
						case 'NOT_PAID':
								filter.Status.value = [];
								filterObject.Status = 'NOT_PAID';
								filterObject.dater = {
										$lte: moment().subtract(10, 'days').toDate()
								};
								break;
						case 'ALL':
								filter.Status.value = [];
								break;
				}

		filterObject.$and = [];

		if (filter && typeof filter === 'object') {
				filterObject.$and.push(filterMapper.mapFilter(filter, {
						contentType: contentType
				})); // caseFilter(filter);
		}

		//return console.log(filterObject.$and[0].$and[0].$or);

		if (options.query.sort) {
				sort = JSON.parse(options.query.sort);
				sort._id = 1;
		} else
				sort = {
						datec: 1,
						_id: 1
				};

		//if (contentType !== 'order' && contentType !== 'integrationUnlinkedOrders') {
		//    Order = MODEL('order').Schema.OrderSupplier;

		//queryObject.$and.push({ _type: 'purchaseOrders' });
		//} else {
		//queryObject.$and.push({ _type: 'Order' });
		//}

		if (pastDue) {
				optionsObject.$and.push({
						expectedDate: {
								$gt: new Date(filter.date.value[1])
						}
				}, {
						'workflow.status': {
								$ne: 'Done'
						}
				});
		}

		accessRollSearcher = function(cb) {
				const accessRoll = MODULE('helper').accessRoll;

				accessRoll(options.user, self, cb);
		};

		contentSearcher = function(ids, cb) {
				var newQueryObj = {};
				const ObjectId = MODULE('utils').ObjectId;

				var salesManagerMatch = {
						$and: [{
										$eq: ['$$projectMember.projectPositionId', ObjectId("570e9a75785753b3f1d9c86e")]
								}, //CONSTANTS.SALESMANAGER
								{
										$or: [{
												$and: [{
														$eq: ['$$projectMember.startDate', null]
												}, {
														$eq: ['$$projectMember.endDate', null]
												}]
										}, {
												$and: [{
														$lte: ['$$projectMember.startDate', '$datec']
												}, {
														$eq: ['$$projectMember.endDate', null]
												}]
										}, {
												$and: [{
														$eq: ['$$projectMember.startDate', null]
												}, {
														$gte: ['$$projectMember.endDate', '$datec']
												}]
										}, {
												$and: [{
														$lte: ['$$projectMember.startDate', '$datec']
												}, {
														$gte: ['$$projectMember.endDate', '$datec']
												}]
										}]
								}
						]
				};

				newQueryObj.$and = [];
				//newQueryObj.$and.push(queryObject);
				//console.log(JSON.stringify(filterObject));
				newQueryObj.$and.push({
						_id: {
								$in: ids
						}
				});

				var late = moment().subtract(10, 'days').toDate();

				var query = [{
								$match: filterObject
						},
						{
								$project: {
										workflow: 1,
										supplier: 1,
										'currency': 1,
										payments: 1,
										salesManagers: {
												$filter: {
														input: '$projectMembers',
														as: 'projectMember',
														cond: salesManagerMatch
												}
										},
										channel: 1,
										salesPerson: 1,
										orderRows: 1,
										paymentInfo: 1,
										datec: 1,
										ref_client: 1,
										dater: 1,
										exported: {
												$size: "$journalId"
										},
										entity: 1,
										total_ttc: 1,
										total_ht: 1,
										total_paid: 1,
										Status: 1,
										ID: 1,
										ref: 1,
										status: 1,
										_type: 1,
										forSales: 1,
										createdAt: 1
								}
						},
						/*{
						                    $lookup: {
						                        from: 'projectMembers',
						                        localField: 'project',
						                        foreignField: 'projectId',
						                        as: 'projectMembers'
						                    }
						            },*/
						/*{
						                   $lookup: {
						                       from: 'Payment',
						                       localField: '_id',
						                       foreignField: 'order',
						                       as: 'payments'
						                   }
						               },*/
						{
								$lookup: {
										from: 'Customers',
										localField: 'supplier',
										foreignField: '_id',
										as: 'supplier'
								}
						},
						/*{
						                   $lookup: {
						                       from: 'workflows',
						                       localField: 'workflow',
						                       foreignField: '_id',
						                       as: 'workflow'
						                   }
						               },*/
						{
								$lookup: {
										from: 'currency',
										localField: 'currency._id',
										foreignField: '_id',
										as: 'currency._id'
								}
						},
						{
								$lookup: {
										from: 'Project',
										localField: 'project',
										foreignField: '_id',
										as: 'project'
								}
						},
						{
								$lookup: {
										from: 'Employees',
										localField: 'salesPerson',
										foreignField: '_id',
										as: 'salesPerson'
								}
						},
						/* {
						                           $lookup: {
						                               from: 'integrations',
						                               localField: 'channel',
						                               foreignField: '_id',
						                               as: 'channel'
						                           }
						                       },*/
						{
								$project: {
										workflow: {
												$arrayElemAt: ['$workflow', 0]
										},
										supplier: {
												$arrayElemAt: ['$supplier', 0]
										},
										'currency._id': {
												$arrayElemAt: ['$currency._id', 0]
										},
										payments: 1,
										'currency.rate': 1,
										salesManagers: 1,
										channel: {
												$arrayElemAt: ['$channel', 0]
										},
										salesPerson: {
												$arrayElemAt: ['$salesPerson', 0]
										},
										orderRows: 1,
										paymentInfo: 1,
										datec: 1,
										ref_client: 1,
										dater: 1,
										exported: 1,
										entity: 1,
										total_ttc: 1,
										total_ht: 1,
										total_paid: 1,
										Status: 1,
										ID: 1,
										ref: 1,
										status: 1,
										_type: 1,
										forSales: 1,
										createdAt: 1
								}
						}, {
								$project: {
										salesManager: {
												$arrayElemAt: ['$salesManagers', 0]
										},
										supplier: {
												_id: '$supplier._id',
												fullName: {
														$concat: ['$supplier.name.first', ' ', '$supplier.name.last']
												}
										},

										workflow: {
												_id: '$workflow._id',
												status: '$workflow.status',
												name: '$workflow.name'
										},

										tempWorkflow: {
												_id: '$tempWorkflow._id',
												status: '$tempWorkflow.status'
										},

										channel: {
												_id: '$channel._id',
												name: '$channel.channelName',
												type: '$channel.type'
										},

										currency: 1,
										paymentInfo: 1,
										datec: 1,
										ref_client: 1,
										dater: 1,
										exported: 1,
										entity: 1,
										total_ttc: 1,
										total_ht: 1,
										total_paid: 1,
										Status: 1,
										ID: 1,
										salesPerson: 1,
										ref: 1,
										isOrder: 1,
										proformaCounter: 1,
										payments: 1,
										status: 1,
										_type: 1,
										forSales: 1,
										createdAt: 1
								}
						}, {
								$match: matchObject
						}, {
								$lookup: {
										from: 'Employees',
										localField: 'salesManager.employeeId',
										foreignField: '_id',
										as: 'salesManager'
								}
						}, {
								$project: {
										salesPerson: {
												$ifNull: ['$salesPerson', {
														$arrayElemAt: ['$salesManager', 0]
												}]
										},
										workflow: 1,
										tempWorkflow: 1,
										supplier: 1,
										currency: 1,
										paymentInfo: 1,
										datec: 1,
										ref_client: 1,
										dater: 1,
										exported: 1,
										entity: 1,
										total_ttc: 1,
										total_ht: 1,
										total_paid: 1,
										Status: 1,
										ID: 1,
										payments: 1,
										ref: 1,
										status: 1,
										_type: 1,
										forSales: 1,
										channel: 1,
										createdAt: 1
								}
						}, {
								$project: {
										salesPerson: {
												_id: '$salesPerson._id',
												fullName: {
														$concat: ['$salesPerson.name.first', ' ', '$salesPerson.name.last']
												}
										},
										workflow: 1,
										tempWorkflow: 1,
										supplier: 1,
										currency: 1,
										paymentInfo: 1,
										datec: 1,
										ref_client: 1,
										dater: 1,
										exported: 1,
										entity: 1,
										total_ttc: 1,
										total_ht: 1,
										total_paid: 1,
										Status: 1,
										ID: 1,
										ref: 1,
										status: 1,
										_type: 1,
										forSales: 1,
										createdAt: 1,
										channel: 1,
										payments: 1,
										removable: {
												$cond: {
														if: {
																$or: [{
																		$eq: ['$workflow.status', 'Done']
																}, {
																		$eq: ['$tempWorkflow.status', 'Done']
																}, {
																		$and: [{
																				$ne: ['$status.fulfillStatus', 'NOR']
																		}, {
																				$ne: ['$status.fulfillStatus', 'NOT']
																		}]
																}]
														},
														then: false,
														else: true
												}
										}
								}
						},
						{
								$match: newQueryObj
						},
						{
								$group: {
										_id: null,
										total: {
												$sum: 1
										},
										total_ht: {
												$sum: "$total_ht"
										},
										total_ttc: {
												$sum: "$total_ttc"
										},
										total_paid: {
												$sum: "$total_paid"
										},
										min: {
												$min: "$total_ht"
										},
										max: {
												$max: "$total_ht"
										},
										avg: {
												$avg: "$total_ht"
										},
										root: {
												$push: '$$ROOT'
										}
								}
						}, {
								$unwind: '$root'
						}, {
								$project: {
										_id: '$root._id',
										salesPerson: '$root.salesPerson',
										workflow: '$root.workflow',
										supplier: '$root.supplier',
										currency: '$root.currency',
										paymentInfo: '$root.paymentInfo',
										datec: '$root.datec',
										ref_client: '$root.ref_client',
										dater: '$root.dater',
										createdAt: '$root.createdAt',
										exported: '$root.exported',
										entity: '$root.entity',
										total_ttc: '$root.total_ttc',
										total_ht: '$root.total_ht',
										total_paid: '$root.total_paid',
										Status: '$root.Status',
										ID: '$root.ID',
										ref: '$root.ref',
										status: '$root.status',
										removable: '$root.removable',
										channel: '$root.channel',
										payments: '$root.payments',
										total: 1,
										totalAll: {
												count: "$total",
												total_ht: "$total_ht",
												total_ttc: "$total_ttc",
												total_paid: "$total_paid",
												min: "$min",
												max: "$max",
												avg: "$avg"
										}
								}
						}, {
								$unwind: {
										path: '$payments',
										preserveNullAndEmptyArrays: true
								}
						}, {
								$project: {
										salesPerson: 1,
										workflow: 1,
										supplier: 1,
										currency: 1,
										paymentInfo: 1,
										datec: 1,
										ref_client: 1,
										dater: 1,
										exported: 1,
										entity: 1,
										total_ttc: 1,
										total_ht: 1,
										total_paid: 1,
										Status: 1,
										ID: 1,
										ref: 1,
										status: 1,
										removable: 1,
										channel: 1,
										createdAt: 1,
										total: 1,
										totalAll: 1,
										'payments.currency': 1,
										'payments.paidAmount': {
												$cond: [{
														$eq: ['$payments.refund', true]
												}, {
														$multiply: ['$payments.paidAmount', -1]
												}, '$payments.paidAmount']
										}
								}
						}, {
								$group: {
										_id: '$_id',
										salesPerson: {
												$first: '$salesPerson'
										},
										workflow: {
												$first: '$workflow'
										},
										supplier: {
												$first: '$supplier'
										},
										currency: {
												$first: '$currency'
										},
										paymentInfo: {
												$first: '$paymentInfo'
										},
										datec: {
												$first: '$datec'
										},
										ref_client: {
												$first: '$ref_client'
										},
										dater: {
												$first: '$dater'
										},
										createdAt: {
												$first: '$createdAt'
										},
										exported: {
												$first: '$exported'
										},
										entity: {
												$first: '$entity'
										},
										total_ttc: {
												$first: '$total_ttc'
										},
										total_ht: {
												$first: '$total_ht'
										},
										total_paid: {
												$first: '$total_paid'
										},
										ID: {
												$first: '$ID'
										},
										Status: {
												$first: '$Status'
										},
										ref: {
												$first: '$ref'
										},
										status: {
												$first: '$status'
										},
										removable: {
												$first: '$removable'
										},
										channel: {
												$first: '$channel'
										},
										paymentsPaid: {
												$sum: {
														$divide: ['$payments.paidAmount', '$payments.currency.rate']
												}
										},
										total: {
												$first: '$total'
										},
										totalAll: {
												$first: '$totalAll'
										}
								}
						}, {
								$project: {
										salesPerson: 1,
										workflow: 1,
										supplier: 1,
										currency: 1,
										paymentInfo: 1,
										datec: 1,
										ref_client: 1,
										dater: 1,
										createdAt: 1,
										exported: 1,
										entity: 1,
										total_ttc: 1,
										total_ht: 1,
										total_paid: 1,
										total_to_paid: {
												$subtract: ["$total_ttc", "$total_paid"]
										},
										Status: {
												$cond: {
														if: {
																$and: [{
																		$eq: ['$Status', 'NOT_PAID']
																}, {
																		$gte: ['$dater', late]
																}]
														},
														then: "VALIDATED",
														else: "$Status"
												}
										},
										ref: 1,
										ID: 1,
										status: 1,
										removable: 1,
										channel: 1,
										paymentsPaid: 1,
										paymentBalance: {
												$subtract: ['$paymentInfo.total', '$paymentsPaid']
										},
										total: 1,
										totalAll: 1
								}
						},
						{
								$sort: sort
						}
				];


				if (skip)
						query.push({
								$skip: skip
						});

				if (limit)
						query.push({
								$limit: limit
						});

				if (options.exec == false) // No execute aggregate : juste return query
						return cb(null, query);

				self.aggregate(query, cb);
		};

		waterfallTasks = [accessRollSearcher, contentSearcher];
		async.waterfall(waterfallTasks, callback);
};

billSchema.statics.getById = function(id, callback) {
		var self = this;
		var ObjectId = MODULE('utils').ObjectId;

		//TODO Check ACL here
		var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
		var query = {};

		if (checkForHexRegExp.test(id))
				query = {
						_id: id
				};
		else
				query = {
						ref: id
				};

		//console.log(query);

		async.waterfall([
						function(wCb) {
								self.findOne(query, "-latex")
										.populate("contacts", "name phone email")
										.populate({
												path: "supplier",
												select: "name salesPurchases",
												populate: {
														path: "salesPurchases.priceList"
												}
										})
										.populate({
												path: "lines.product",
												select: "taxes info weight units",
												//populate: { path: "taxes.taxeId" }
										})
										.populate({
												path: "lines.total_taxes.taxeId"
										})
										.populate({
												path: "total_taxes.taxeId"
										})
										.populate("createdBy", "username")
										.populate("editedBy", "username")
										.populate("offer", "ref total_ht forSales")
										.populate("order", "ref total_ht forSales")
										.populate("orders", "ref total_ht forSales")
										.populate('invoiceControl')
										.populate('project', '_id name')
										.populate('shippingMethod', '_id name')
										.populate('workflow', '_id name status')
										.exec(wCb);
						}
				],
				function(err, invoice) {
						if (err)
								return callback(err);

						return callback(err, invoice);
				});
};

billSchema.statics.setInvoiceNumber = function(invoice, callback) {
		var SeqModel = MODEL('Sequence').Schema;
		var EntityModel = MODEL('entity').Schema;

		if (!invoice || invoice.Status == 'DRAFT' || invoice.total_ttc === 0) {
				invoice.Status = 'DRAFT';
				return callback(null, invoice);
		}

		if (invoice.ref.substr(0, 4) !== "PROV")
				return callback(null, invoice);

		if (invoice.forSales == true)
				return SeqModel.inc("INVOICE", function(seq, number) {
						//console.log(seq);
						invoice.ID = number;
						EntityModel.findOne({
								_id: invoice.entity
						}, "cptRef", function(err, entity) {
								if (err)
										console.log(err);

								if (entity && entity.cptRef)
										invoice.ref = (invoice.total_ttc < 0 ? "AV" : "FA") + entity.cptRef + seq;
								else
										invoice.ref = (invoice.total_ttc < 0 ? "AV" : "FA") + seq;

								callback(null, invoice);
						});
				});
};

billSchema.statics.generatePdfById = function(id, model, callback) {
		// Generation de la facture PDF et download
		const SocieteModel = MODEL('Customers').Schema;
		const BankModel = MODEL('bank').Schema;
		const ModelPDFModel = MODEL('modelspdf').Schema;

		const self = this;

		async.waterfall([

				function(wCb) {
						ModelPDFModel.findById(model, function(err, doc) {
								if (err)
										return wCb(err);

								return wCb(null, doc);
						});
				},
				function(model, wCb) {
						if (model)
								return wCb(null, model);

						//Load default model
						ModelPDFModel.findOne({
								module: 'bill',
								isDefault: true
						}, function(err, doc) {
								if (err)
										return wCb(err);

								if (!doc)
										return wCb("No model PDF found");

								return wCb(null, doc);
						});
				},
				function(modelPdf, wCb) {
						var discount = false;
						// Generation de la facture PDF et download


						var cond_reglement_code = {};
						Dict.dict({
								dictName: "fk_payment_term",
								object: true
						}, function(err, docs) {
								cond_reglement_code = docs;
						});
						var mode_reglement_code = {};
						Dict.dict({
								dictName: "fk_paiement",
								object: true
						}, function(err, docs) {
								mode_reglement_code = docs;
						});

						self.getById(id, function(err, doc) {

								// check if discount
								for (var i = 0; i < doc.lines.length; i++) {
										if (doc.lines[i].discount > 0) {
												discount = true;
												break;
										}
								}

								SocieteModel.findOne({
										_id: doc.supplier.id
								}, function(err, societe) {
										BankModel.findOne({
												_id: doc.bank_reglement
										}, function(err, bank) {
												if (bank)
														var iban = bank.name_bank + "\n RIB : " + bank.code_bank + " " + bank.code_counter + " " + bank.account_number + " " + bank.rib + "\n IBAN : " + bank.iban + "\n BIC : " + bank.bic;

												// Array of lines
												var tabLines = [];

												for (var i = 0; i < doc.lines.length; i++) {
														switch (doc.lines[i].type) {
																case 'SUBTOTAL':
																		tabLines.push({
																				type: 'subtotal',
																				label: "Sous-total",
																				total_ht: doc.lines[i].total_ht
																				//buttomhline: 1
																		});
																		break;
																case 'COMMENT':
																		tabLines.push({
																				type: 'comment',
																				label: '',
																				description: "\\textbf{" + doc.lines[i].refProductSupplier + "}" + (doc.lines[i].description ? "\\\\" + doc.lines[i].description : "")
																		});
																		break;
																default:
																		//console.log(doc.lines[i]);
																		tabLines.push({
																				type: 'product',
																				seq: doc.lines[i].numLine,
																				ref: doc.lines[i].product.info.SKU.substring(0, 12),
																				label: doc.lines[i].product.info.langs[0].name,
																				description: doc.lines[i].description + (doc.lines[i].total_taxes.length > 1 ? "\\\\\\textit{" + doc.lines[i].total_taxes[1].taxeId.langs[0].name + " : " + doc.lines[i].product.taxes[1].value + " \\euro}" : ""),
																				tva_tx: (doc.lines[i].total_taxes.length ? doc.lines[i].total_taxes[0].taxeId.rate : 0),
																				pu_ht: doc.lines[i].pu_ht,
																				discount: doc.lines[i].discount,
																				qty: doc.lines[i].qty,
																				unit: doc.lines[i].product.units || "U",
																				total_ht: doc.lines[i].total_ht
																		});
														}

												}

												// Array of totals
												var tabTotal = [];

												// Frais de port
												if (doc.shipping && doc.shipping.total_ht)
														tabTotal.push({
																label: "Frais de port",
																value: doc.shipping.total_ht
														});

												// Remise globale
												if (doc.discount && doc.discount.discount && doc.discount.discount.percent)
														tabTotal.push({
																italic: true,
																label: "Remise globale " + doc.discount.discount.percent + ' %',
																value: doc.discount.discount.value * -1
														});

												// Escompte
												if (doc.discount && doc.discount.escompte && doc.discount.escompte.percent)
														tabTotal.push({
																italic: true,
																label: "Escompte " + doc.discount.escompte.percent + ' %',
																value: doc.discount.escompte.value * -1
														});

												//Total HT
												tabTotal.push({
														label: "Total HT",
														value: doc.total_ht
												});

												for (var i = 0; i < doc.total_taxes.length; i++)
														tabTotal.push({
																label: "Total " + doc.total_taxes[i].taxeId.langs[0].label,
																value: doc.total_taxes[i].value
														});

												//Total TTC
												tabTotal.push({
														label: "Total TTC",
														value: doc.total_ttc
												});

												var reglement = "";
												switch (doc.mode_reglement_code) {
														case "VIR":
																if (doc.bank_reglement) // Bank specific for payment
																		reglement = "\n" + (bank.invoice ? bank.invoice : bank.iban.id);
																else // Default IBAN
																		reglement = "\n --IBAN--";
																break;
														case "CHQ":
																if (doc.bank_reglement) // Bank specific for payment
																		reglement = "\n" + (bank.invoice ? bank.invoice : "");
																//else
																//		reglement = "A l'ordre de --ENTITY--";
																break;
												}

												/*tab_latex += "Total HT &" + latex.price(doc.total_ht) + "\\tabularnewline\n";
												 for (var i = 0; i < doc.total_tva.length; i++) {
												 tab_latex += "Total TVA " + doc.total_tva[i].tva_tx + "\\% &" + latex.price(doc.total_tva[i].total) + "\\tabularnewline\n";
												 }
												 tab_latex += "\\vhline\n";
												 tab_latex += "Total TTC &" + latex.price(doc.total_ttc) + "\\tabularnewline\n";*/

												//Periode de facturation
												var period = "";
												if (doc.dateOf && doc.dateTo)
														period = "\\textit{P\\'eriode du " + moment(doc.dateOf).format(CONFIG('dateformatShort')) + " au " + moment(doc.dateTo).format(CONFIG('dateformatShort')) + "}\\\\";

												Latex.Template(modelPdf.latex, doc.entity, {
																cgv: false, //TODO Quid des CGV !
																module: 'bill'
														})
														.apply({
																pdfModel: {
																		value: {
																				hbuttom: doc.pdfModel.hbuttom,
																				htop: doc.pdfModel.htop
																		}
																},
																isDiscount: {
																		value: discount,
																		type: 'boolean'
																},
																ref: {
																		value: doc.ref
																},
																title: {
																		value: (doc.total_ttc < 0 ? "Avoir" : "Facture")
																},
																to: {
																		value: {
																				name: doc.address.name || doc.supplier.fullName,
																				address: doc.address.toObject(),
																				tva: societe.companyInfo.idprof6,
																				codeClient: societe.salesPurchases.ref
																		}
																},
																refClient: {
																		value: doc.ref_client
																},
																period: {
																		value: period
																},
																datec: {
																		value: doc.datec
																},
																dateech: {
																		value: doc.dater
																},
																reglement: {
																		value: cond_reglement_code.values[doc.cond_reglement_code].label
																},
																paid: {
																		value: mode_reglement_code.values[doc.mode_reglement_code].label
																},
																coupon: {
																		value: (doc.forSales == true && doc.mode_reglement_code == 'CHQ' ? 'CHQ' : "")
																},
																notes: {
																		value: (doc.notes.length ? doc.notes[0].note : ""),
																},
																bank: {
																		value: reglement
																},
																lines: {
																		value: tabLines
																},
																linesRef: {
																		value: tabLines
																},
																total: {
																		value: tabTotal
																},
																APAYER: {
																		value: doc.total_ttc || 0
																}
														})
														.on('error', wCb)
														.finalize(function(tex) {
																//console.log('The document was converted.');

														})
														.compile()
														.pipe(fs.createWriteStream(F.path.root() + '/uploads/pdf/' + doc._id + "_" + modelPdf.code + ".pdf"))
														.on('end', function() {
																//console.log('document written');

																self.update({
																		_id: doc._id,
																		'pdfs.modelPdf': modelPdf._id
																}, {
																		$set: {
																				'pdfModel.modelId': modelPdf._id,
																				'pdfs.$.filename': doc.ref + modelPdf.filename,
																				"pdfs.$.datec": new Date()
																		}
																}, {
																		upsert: false
																}, function(err, res) {
																		if (err)
																				return wCb(err);

																		if (res && res.nModified)
																				return wCb(); // Already exist and updated

																		//console.log(modelPdf);

																		//create new entry in order
																		self.update({
																				_id: doc._id
																		}, {
																				$set: {
																						'pdfModel.modelId': modelPdf._id
																				},
																				$push: {
																						"pdfs": {
																								filename: doc.ref + modelPdf.filename,
																								fileId: doc._id + "_" + modelPdf.code + ".pdf",
																								modelPdf: modelPdf._id,
																								datec: new Date()
																						}
																				}
																		}, {
																				upsert: false
																		}, function(err, doc) {
																				if (err)
																						return wCb(err);

																				wCb();
																		});
																});
														});
										});
								});
						});
				}
		], callback);
};

/**
 * Pre-save hook
 */
billSchema.pre('save', function(next) {

		var self = this;
		var SeqModel = MODEL('Sequence').Schema;
		var EntityModel = MODEL('entity').Schema;

		this.dater = MODULE('utils').calculate_date_lim_reglement(this.datec, this.cond_reglement_code);

		if (this.isNew)
				this.history = [];

		if (self.total_ttc === 0)
				self.Status = 'DRAFT';

		if (!self.ref && self.isNew) {
				if (self.forSales == true)
						return SeqModel.inc("PROV", function(seq, number) {
								//console.log(seq);
								self.ID = number;
								self.ref = "PROV" + seq;
								next();
						});
				//supplier invoice
				return SeqModel.inc("SUPPLIER_INVOICE", function(seq, number) {
						//console.log(seq);
						self.ID = number;
						EntityModel.findOne({
								_id: self.entity
						}, "cptRef", function(err, entity) {
								if (err)
										console.log(err);

								/*if (entity && entity.cptRef)
								    invoice.ref = "FF" + entity.cptRef + seq;
								else*/
								self.ref = "FF" + seq;
								next();
						});
				});
		}


		self.ref = F.functions.refreshSeq(self.ref, self.datec);
		next();
});

/*var statusList = {};
Dict.dict({ dictName: 'fk_bill_status', object: true }, function(err, doc) {
    if (err) {
        console.log(err);
        return;
    }
    statusList = doc;
});*/

exports.Status = {
		"_id": "fk_bill_status",
		"lang": "orders",
		"values": {
				"DRAFT": {
						"enable": true,
						"label": "BillStatusDraft",
						"cssClass": "ribbon-color-default label-default",
						"system": true
				},
				"VALIDATED": {
						"enable": true,
						"label": "BillStatusValidated",
						"cssClass": "ribbon-color-success label-success"
				},
				"NOT_PAID": {
						"enable": true,
						"label": "BillStatusNotPaid",
						"cssClass": "ribbon-color-danger label-danger",
						"system": true
				},
				"PAID": {
						"enable": true,
						"label": "BillShortStatusPaid",
						"cssClass": "ribbon-color-success label-success",
						"system": true
				},
				"STARTED": {
						"enable": true,
						"label": "BillStatusStarted",
						"cssClass": "ribbon-color-warning label-warning",
						"system": true
				},
				"PAID_PARTIALLY": {
						"enable": true,
						"label": "BillStatusClosedPaidPartially",
						"cssClass": "ribbon-color-info label-info",
						"system": true
				},
				"CANCELED": {
						"enable": true,
						"label": "BillStatusCanceled",
						"cssClass": "ribbon-color-warning label-warning",
						"system": true
				},
				"CONVERTED_TO_REDUC": {
						"enable": true,
						"label": "BillStatusConvertedToReduc",
						"cssClass": "ribbon-color-success label-success",
						"system": true
				},
				"PAID_BACK": {
						"enable": true,
						"label": "BillShortStatusPaid",
						"cssClass": "ribbon-color-success label-success",
						"system": true
				}
		}
};

billSchema.virtual('_status')
		.get(function() {
				var status = this.Status;

				if (status === 'NOT_PAID' && this.dater > moment().subtract(10, 'days').toDate()) //Check if late
						status = 'VALIDATED';

				return MODULE('utils').Status(status, exports.Status);
		});

/*var transactionList = [];

 TransactionModel.aggregate([
 {$group: {
 _id: '$bill.id',
 sum: {$sum: '$credit'}
 }}
 ], function (err, doc) {
 if (err)
 return console.log(err);

 transactionList = doc;
 });*/

billSchema.virtual('amount').get(function() {

		var amount = {};
		var id = this._id;



		/*if (transactionList) {
		 for (var i = 0; i < transactionList.length; i++) {
		 if (id.equals(transactionList[i]._id)) {
		 amount.rest = this.total_ttc - transactionList[i].sum;
		 amount.set = transactionList[i].sum;
		 return amount;
		 }
		 }
		 }*/

		return this.total_ttc - this.total_paid;
});

exports.Schema = mongoose.model('invoice', billSchema, 'Invoices');
exports.name = 'invoice';

F.on('invoice:recalculateStatus', function(data) {
		var userId = data.userId;
		const BillModel = MODEL('invoice').Schema;
		const TransactionModel = MODEL('transaction').Schema;
		const ObjectId = MODULE('utils').ObjectId;

		//console.log(data);
		console.log("Update emit invoice", data);

		if (!data.invoice || !data.invoice._id)
				return;

		BillModel.findById(data.invoice._id, "_id Status isremoved total_ttc", function(err, bill) {
				if (err)
						return console.log(err);

				if (!bill)
						return console.log("No bill found");

				if (bill.isremoved)
						return BillModel.update({
								_id: bill._id
						}, {
								$set: {
										updatedAt: new Date(),
										total_ttc: 0,
										total_paid: 0,
										total_ht: 0
								}
						}, function(err, doc) {
								if (err)
										return console.log(err);
						});

				if (bill.Status == "DRAFT")
						return;

				TransactionModel.aggregate([{
								$match: {
										"meta.bills.invoice": ObjectId(data.invoice._id),
										voided: false,
										$or: [{
												"meta.bank": {
														$ne: null
												}
										}, {
												"meta.isWaiting": true
										}],
								}
						}, {
								$unwind: {
										path: '$meta.bills'
								}
						}, {
								$match: {
										"meta.bills.invoice": ObjectId(data.invoice._id)
								}
						}, {
								$group: {
										_id: null,
										amount: {
												$sum: "$meta.bills.amount"
										}
								}
						}],
						function(err, doc) {
								if (err)
										return console.log(err);

								//console.log(doc);

								if (!doc || doc.length == 0)
										return BillModel.update({
												_id: bill._id
										}, {
												$set: {
														Status: "NOT_PAID",
														updatedAt: new Date(),
														total_paid: 0
												}
										}, function(err, doc) {
												if (err)
														return console.log(err);
										});

								let payment = doc[0].amount;
								//console.log(payment);

								var status = "STARTED";
								if (round(payment, 2) >= round(bill.total_ttc, 2))
										status = "PAID";

								if (round(payment, 2) == 0)
										status = "NOT_PAID";

								BillModel.update({
										_id: bill._id
								}, {
										$set: {
												Status: status,
												updatedAt: new Date(),
												total_paid: payment
										}
								}, function(err, doc) {
										if (err)
												return console.log(err);
										//console.log(doc);
								});
						});
		});
});

F.on('invoice:update', function(data, Model) {

		//console.log(data);
		console.log("Update emit invoice !", data);
		if (!data || !data.bill || !data.bill._id)
				return;

		async.parallel([
				function(pCb) {
						if (!Model) //Refresh PDF
								return pCb();

						Model.findOne({
								_id: data.bill._id,
								Status: {
										$nin: ["DRAFT", "CANCELLED"]
								}
						}, "pdfs ref pdfModel", function(err, doc) {
								if (err)
										return pCb(err);

								if (!doc)
										return pCb();

								if (doc.pdfModel && doc.pdfModel.modelId)
										Model.generatePdfById(data.bill._id, doc.pdfModel.modelId, function(err) {
												if (err)
														console.log(err);
										});
								else
										return Model.generatePdfById(data.bill._id, null, function(err, doc) {
												if (err)
														return pCb(err);

												pCb(null, doc);
										});

								if (!doc.pdfs.length)
										return pCb();

								async.each(doc.pdfs, function(elem, eCb) {
										if (elem.modelPdf.toString() == doc.pdfModel.modelId.toString())
												return eCb(); // already execute

										Model.generatePdfById(data.bill._id, elem.modelPdf, eCb);
								}, function(err) {
										if (err)
												return pCb(err);

										pCb(null, doc);
								});
						});
				},
				function(pCb) {
						pCb(null, null);



				}
		], function(err, result) {
				if (err)
						return console.log(err);

				if (!data.route)
						return;

				if (!result[0])
						return;

				if (data.userId)
						F.emit('notify:controllerAngular', {
								userId: data.userId,
								route: data.route,
								_id: result[0]._id.toString(),
								message: result[0].ref + ' modifiee.'
						});


				setTimeout2('notifybill:controllerAngular', function() {
						F.emit('notify:controllerAngular', {
								userId: null,
								route: data.route,
								//_id: el._id.toString(),
								//message: "Commande " + el.ref + ' modifie.'
						});
				}, 60000);


		});

});
